
<script src="/local/custom_ui/lib/moment.min.js"></script>

<meta name="viewport" content="width=device-width">

<dom-module id='ha-panel-tvshows'>
  <template>
    <style include="ha-style">
      .container {
        height: 100%;
        vertical-align: top;
        position: relative;
        padding: 0px 10px 0px 10px;
      }
      .loading-container {
        text-align: center;
        padding: 8px;
      }
      [hidden] {
        display: none !important;
      }
      .tvshows-list-table {
        width: 100%;
        border-spacing: 0px !important;
      }
      .tvshows-list-table td {
        border: none !important;
        border-spacing: 0px !important;
        line-height: 20px !important;
      }
      .tvshows-list-item {
        font-weight: $font-light;
        width: 100%;
        font-size: 16px;
        text-align: left !important;
        transition: 0.8s padding ease;
      }
      .tvshows-list-item:hover {
        background-color: #d9e6f2;
      }
      .episode-table {
        width: 100%;
      }
      .episode-table td {
        border: none !important;
        border-spacing: 0px !important;
        line-height: 20px !important;
      }
      .episode-poster-container {
        height: 150px;
        display: block;
        position: relative;
        z-index: 1;
      }
      .episode-poster {
        height: 150px;
        display: block;
              position: absolute;
        z-index: 2;
      }
      .episode-watched {
          position: relative;
        z-index: 3;
        color: #91d160;
        --iron-icon-stroke-color: #91d160;
      }
      .episode-showtitle {
        padding: 0px 0px 0px 15px;
        font-weight: 500;
        font-size: 18px;
      }
      .episode-seasoninfo {
        padding: 0px 0px 0px 0px;
        font-size: 12px;
        text-align: right;
      }
      .episode-title {
        padding: 5px 0px 0px 15px;
      }
      .episode-date {
        padding: 0px 0px 0px 0px;
        text-align: right;
        font-size: 10px;
      }
    </style>
    <app-header-layout has-scrolling-region="">
      <app-header fixed="">
        <app-toolbar>
          <ha-menu-button narrow="[[narrow]]" show-menu="[[showMenu]]"></ha-menu-button>
          <div main-title="">[[panel.title]]</div>
          <paper-icon-button icon="mdi:refresh" on-tap="handleRefreshClick" alt="Refresh"></paper-icon-button>
        </app-toolbar>
      </app-header>

      <div class="container">
        <h1>Recent Episodes</h1>
        <div hidden$="[[!isLoading]]" class='loading-container'>
          <paper-spinner active alt='Updating history data'></paper-spinner>
        </div>
        <table class='tvshows-list-table'>
            <template is='dom-repeat' items='[[_episodes]]' as='episode'>
              <tr>
                <td on-tap='episodeSelected' style="padding:0px">
                  <div class='tvshows-list-item'>
                    <table class='episode-table'>
                      <tr style="width:100%; padding:0px; margin:0px; border:0px">
                        <td style="width:100px">
                          <div class="episode-poster-container">
                            <img src=[[artUrl(episode.library.art)]] class="episode-poster">
                            <iron-icon icon="mdi:check-circle-outline" class="episode-watched" style="display: [[isWatchedDisplayType(episode.library.playcount)]];"></iron-icon>
                          </div>
                        </td>
                        <td style="vertical-align:top; width:*">
                          <div class="episode-showtitle">[[episode.library.showtitle]]</div>
                          <div class="episode-seasoninfo">season [[episode.library.season]]&nbsp;&nbsp;&nbsp; episode [[episode.library.episode]]</div>
                          <div class="episode-title">[[episode.library.title]]</div>
                          <div class="episode-date">[[episode.library.dateadded]]</div>
                        </td>
                      </tr>
                    </table>
                  </div>
                </td>
              </tr>
            </template>
        </table>
      </div>
    </app-header-layout>
  </template>
</dom-module>

<script>
class Log {
  constructor(debug) {
  if (debug) {
    this.debugLog = console.log.bind(window.console, 'DBG: ');
    this.errorLog = console.log.bind(window.console, 'ERR: ');
  }
  else {
    this.debugLog = function () { };
    this.errorLog = function () { };
  }
  }
  d(msg) {
    this.debugLog(msg);
  }
  e(msg) {
    this.errorLog(msg);
  }
}
log = new Log(true);

class HaPanelTvShows extends Polymer.Element {
  static get is() { return 'ha-panel-tvshows'; }
  
  static get properties() {
    return {
      // Home Assistant object
      hass: {
        type: Object,
        observer: 'hassChanged'
      },
      // If should render in narrow mode
      narrow: {
        type: Boolean,
        value: false,
      },
      // If sidebar is currently shown
      showMenu: {
        type: Boolean,
        value: false,
      },
      // Home Assistant panel info
      // panel.config contains config passed to register_panel serverside
      panel: Object,
      // other params
      isLoading: {
        type: Boolean,
        notify: true,
        value: true,
      },
      timeDifference: {
        type: Number,
        value: undefined,
      },
      _episodes: {
        type: Array,
        notify: true,
        value: function() {
          return [];
        }
      },
      who: {
        type: String,
        computed: 'computeWho(panel)',
      },
    };
  }

  constructor() {
    super();
  }

  ready() {
    super.ready();
    log.d("ready");
    
    this.initEventPorcessing();
    this.getRecentEpisodes();
  }

  hassChanged(newHass, oldHass) {
    //this.handleEntities(newHass.states);
    //log.d('hassChanged')
  }

  initEventPorcessing() {
    self = this;
    var source = new EventSource("/api/stream"); //var source = new EventSource("/api/stream?api_password=YOUR_PASSWORD");

    source.onmessage = function(event) {
      // skip ping events
      if ("ping" === event.data) {
        return;
      }

      var obj = JSON.parse(event.data);

      // store time difference
      if (obj.time_fired) {
        let lastEventFiredTime = moment(obj.time_fired).toDate();
        self.timeDifference = moment().diff(moment(lastEventFiredTime), 'milliseconds');
        //log.d('init - time difference: ' + self.timeDifference);
      }

      // process events based on event_type
      if (obj.event_type == "rssshows_latest") {
        log.d('RX - received rssshows latest')

        var eplist = JSON.parse(obj.data.latest);
        //self._episodes = eplist;
        //for (var i in eplist) {
        //  console.log(eplist[i]);
        //  if (typeof ep.library !== 'undefined')
        //    self._episodes.append(eplist[i])
        //}
        self._episodes = eplist.sort(function (a, b) {
          if (a.library.playcount > b.library.playcount) return 1;
          else if (a.library.playcount < b.library.playcount) return -1;
          else {
            if (a.library.dateadded < b.library.dateadded) return 1;
            else return -1;
          }
        });

        self.isLoading = false;
      }
      //else if (obj.event_type == "state_changed") {
      //  log.d('RX - received state changed')
      //}
    }
  }

  getRecentEpisodes() {
    this._episodes = [];
    log.d('TX - call service rssshows.latest')
    this.hass.callService('rssshows', 'latest', {});
  }

  handleRefreshClick() {
    self.isLoading = true;
    this.getRecentEpisodes();
  }

  episodeSelected(ev) {
    //var index = ev.model.index;
    //ev.preventDefault();
  }

  artUrl(art) {
    var elem = null;
    var path = 'season.poster';
    if ((typeof art[path] == 'string') && art[path].startsWith("image://http%3a%2f%2")) {
      elem = art[path];
    }
    else {
      var path = 'tvshow.poster';
      if ((typeof art[path] == 'string') && art[path].startsWith("image://http%3a%2f%2")) {
        elem = art[path];
      }
    }
    if (elem != null) {
      var enURI = art[path].substring(8, art[path].length - 1);
      return decodeURI(decodeURIComponent(enURI.replace(/\+/g, " ")));
    }
    else {
      return "nopic";
    }
  }
  
  isWatchedDisplayType(playCount) {
    if (playCount > 0)
      return 'block';
    return 'none';
  }

  computeWho(panel) {
    return panel && panel.config && panel.config.testvar ? panel.config.testvar : 'World';
  }
}
customElements.define(HaPanelTvShows.is, HaPanelTvShows);
</script>